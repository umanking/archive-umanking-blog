---
layout: post
title: "[이펙티브 자바 3판] 아이템 4.인스턴스화를 막으려거든 private 생성자를 사용하라"
categories: [Effective Java]
date: 2020-02-19 20:43 +0900
---
<!-- TOC -->

- [정적 메서드와 정적 필드는 언제 만드나?](#%ec%a0%95%ec%a0%81-%eb%a9%94%ec%84%9c%eb%93%9c%ec%99%80-%ec%a0%95%ec%a0%81-%ed%95%84%eb%93%9c%eb%8a%94-%ec%96%b8%ec%a0%9c-%eb%a7%8c%eb%93%9c%eb%82%98)
- [인스턴스화를 막는 방법](#%ec%9d%b8%ec%8a%a4%ed%84%b4%ec%8a%a4%ed%99%94%eb%a5%bc-%eb%a7%89%eb%8a%94-%eb%b0%a9%eb%b2%95)

<!-- /TOC -->
## 정적 메서드와 정적 필드는 언제 만드나? 
`정적 메서드`와 `정적 필드`만을 담은 클래스를 만들고 싶을 때가 있다. 객체 지향적으로 사고하지 않는 이들이 종종 남용하는 방식이기에 그리 곱게 보이지는 않지만, 분명 나름의 쓰임이 있다.

- Math, Arrays처럼 기본 타입 값이나 배열 관련 메서드들을 모아 놓을 수 있다.
- Collections처럼 특정 인터페이스를 구현하는 객체를 생성해주는 정적 메서드(혹은 팩터리)를 모아놓을 수도 있다. (자바 8부터는 이런 메서드를 인터페이스에 넣을 수 있다.) 
- final 클래스와 관련한 메서드들을 모아 놓을 때도 사용한다. final 클래스를 상속해서 하위 클래스에 메서드를 넣는 건 불가능하기 때문이다. 

정적 멤버만 담은 유틸리티 클래스는 인스턴스로 만들어 쓰려고 설계한 게 아니다.
하지만 생성자를 명시하지 않으면 컴파일러가 자동으로 기본 생성자를 만들어 준다. 즉, 매개변수를 받지 않는 public 생성자가 만들어 지며 사용자는 이 생성자가 자동 생성된 것인지 구분할 수 없다.
 실제로 공개된 API들에서도 이처럼 의도치 않게 인스턴스화 할 수 있게 된 클래스가 종종 목격되곤 한다.

**추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없다.** 하위 클래스를 만들어 인스턴스화 하면 그만이다. 이를 본 사용자는 상속해서 쓰라는 뜻으로 오해할 수 있으니 더 큰 문제다. 

## 인스턴스화를 막는 방법 
아주 간단하다. 컴파일러가 기본 생성자를 만드는 경우는 오직 명시된 생성자가 없을 때 뿐이니 private 생성자를 추가하면 클래스의 인스턴스화를 막을 수 있다. 

```java
public class UtilityClass{
    // 기본 생성자가 만들어 지는 것을 막는다(인스턴스화 방지용)
    private UtilityClass() {
        throw new AssertionError();
    }
}
```
**이 코드는 어떤 환경에서도 클래스가 인스턴스화 되는 것을 막아 준다.** 그런데 생성자가 존재하는데 호출할 수 없다니, 그다지 직관적이지 않다. 그러니 앞의 코드 처럼 적절하게 주석을 달자. 이 방식은 상속을 불가능하게 하는 효과도 있다. 모든 생성자는 명시적이든 묵시적이든 상위 클래스의 생서자를 호출하게 되는데, 이를 private으로 선언 했으니 하위 클래스가 상위 클래스의 생성자에 접근할 길이 없다. 
